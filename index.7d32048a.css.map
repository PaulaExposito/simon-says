{"mappings":"AAAA,KAGA,kBAAA,CAEA,qBAAA,CAHA,qBAIA,CAEA,UAPA,YAWA,CAJA,KAEA,sBAAA,CACA,UACA,CCigBA,8BACE,qBAAuB,CACvB,WAAY,CACZ,UACF,CC9fA,qBDigBE,kBAAW,CACX,UAAY,CAFZ,UC5fF,CDggBA,qBAEE,eAAI,CChgBJ,WAEF,CACA,0BDggBA,wBAAA,CAEE,UAAS,CAET,cAAY,CClgBZ,WAAY,CDigBZ,iBAAkB,CAElB,UC9fF,CC2CA,MAOE,kBAA2B,CAF3B,YAAa,CAFb,sBAAuB,CAGvB,YAEF,CDtCA,eCgCE,kBAAmB,CADnB,YD1BF,CALA,SC2CE,4BAAmB,CAHnB,UDnCF,CEtBA,WAGE,aACF,CF2BA,EEzBE,aAAA,CACA,iBF2BF,CGrCA,WCgEE,kBAAmB,CALnB,wBAAgC,CAGhC,YAAa,CD5Db,qBAAsB,CCwDtB,YAAa,CAKb,sBAAuB,CAHvB,eAAgB,CAHhB,SDtDF","sources":["src/css/index.css","src/js/components/Game.vue","%3Cinput%20css%20UEaCUS%3E","src/js/components/Login.vue","src/js/components/Instructions.vue","src/js/components/Lose.vue","src/js/App.vue"],"sourcesContent":["body {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n\n    background-color: lightslategray;\n}\n\n#app {\n    display: flex;\n    justify-content: center;\n    width: 100%;\n}","<template>\n  <div class=\"containerGame\">\n    <n-space class=\"info\" justify=\"space-around\">\n      <span><b>Tiempo restante:</b> {{ time }}</span>\n      <span><b>Ronda:</b> {{ round }}</span>\n      <span><b>Nivel:</b> {{ rules[level].name }}</span>\n    </n-space>\n\n    <div id=\"countdown\"></div>\n    <div id=\"game\"></div>\n  </div>\n</template>\n\n<script>\nimport { NButton, NSpace } from \"naive-ui\";\nimport { STATES, COLORS, SHINE_COLOR } from \"../../assets/variables\";\n\nlet objects = [], animations = []; \nlet colorsIndexSelected = [], geometriesSelected = [];\nlet scene, camera, renderer, light;\n\n// Eventos\nlet clock, pickPosition, pickHelper;\nlet resquestAnimationId, remandingTimeIntervalId, loseTimeoutId;\n\nclass PickHelper {\n  constructor() {\n    this.raycaster = new THREE.Raycaster();\n    this.pickedObject = null;\n    this.pickedObjectSavedColor = 0;\n  }\n  pick(normalizedPosition, scene, camera, time, userSequence) {\n    // cast a ray through the frustum\n    this.raycaster.setFromCamera(normalizedPosition, camera);\n    // get the list of objects the ray intersected\n    const intersectedObjects = this.raycaster.intersectObjects(scene.children);\n    if (intersectedObjects.length) {\n      // pick the first object. It's the closest one\n      this.pickedObject = intersectedObjects[0].object;\n      // save its color\n      this.pickedObjectSavedColor =\n        this.pickedObject.material.emissive.getHex();\n      // set its emissive color to flashing red/yellow\n      this.pickedObject.material.emissive.setHex(SHINE_COLOR);\n\n\n      // Save clicked object\n      userSequence.push(this.pickedObject);\n\n      setTimeout(() => {\n        this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);\n        this.pickedObject = undefined;\n      }, 400);\n    }\n  }\n\n  backLastColor() {\n    this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);\n  }\n}\n\nexport default {\n  name: \"Game\",\n  components: {\n    NButton,\n    NSpace,\n  },\n  props: {\n    level: Number,\n    roundInfo: Object,\n  },\n  data() {\n    return {\n      sequence: [],\n      userSequence: [],\n      sequenceSize: 0,\n      time: 0,\n      round: 0,\n      running: false,\n      rules: {\n        0: {\n          name: \"Fácil\",\n          numObjects: 4,\n          timeObjectIlluminated: 3,   // Tiempo que está iluminado el objeto\n          timeMultiplier: 3, // 3 * sequenceSize\n        },\n        1: {\n          name: \"Medio\",\n          numObjects: 5,\n          timeObjectIlluminated: 2,\n          timeMultiplier: 2,\n        },\n        2: {\n          name: \"Difícil\",\n          numObjects: 6,\n          timeObjectIlluminated: 1,\n          timeMultiplier: 1.5,\n        },\n      },\n    };\n  },\n  mounted() {\n    this.fillNotFirstRoundInfo();\n    this.displayInfo();\n    this.displayCountdown(3, \"¡YA!\");\n  },\n  watch: {\n    running() {\n      if (this.running === true) {\n        if (this.round === 1) \n          this.start();\n        else\n          this.restart();\n      }\n    },\n  },\n  methods: {\n    nextState(action) {\n      if (action === \"win\")\n        this.$emit(\"changeState\", { state: STATES.WIN_STATE });\n      else this.$emit(\"changeState\", { state: STATES.LOSE_STATE });\n    },\n    displayInfo() {\n      this.round++;\n      this.sequenceSize = this.round;\n      this.time =\n        this.sequenceSize *\n        this.rules[this.level].timeMultiplier;\n    },\n    // countdown is the initial number of seconds\n    displayCountdown(contdown, msg) {\n      const intervalId = setInterval(countdown, 1000);\n      const node = document.getElementById(\"countdown\");\n      node.style.display = \"block\";\n      const thisOrigin = this;\n\n      function countdown() {\n        if (contdown == 0) {\n          node.textContent = msg;\n          clearInterval(intervalId);\n          setTimeout(() => {\n            node.style.visibility = \"hidden\";\n            thisOrigin.running = true;\n          }, 1000);\n        } else {\n          node.textContent = contdown;\n          contdown--;\n        }\n      }\n    },\n    start() {\n      this.initWorld();\n\n      // Build the objects\n      for (let i = 0; i < this.rules[this.level].numObjects; ++i) {\n        this.createObject(i);\n      }\n\n      // Set camera position\n      camera.position.z = 5;\n\n      // Reloj\n      clock = new THREE.Clock();\n\n      // Render the scene\n      // It is a loop that draw the scene every time the screen is refresed (about 60 times/second)\n      this.animate();\n\n      // Play\n      this.play();\n    },\n    restart() {\n      const gameNode = document.getElementById(\"game\");\n\n      renderer = new THREE.WebGLRenderer();\n      renderer.setSize(gameNode.clientWidth, gameNode.clientHeight);\n      document.getElementById(\"game\").appendChild(renderer.domElement);\n\n      camera.position.z = 5;\n      clock = new THREE.Clock();\n\n      // Render the scene\n      // It is a loop that draw the scene every time the screen is refresed (about 60 times/second)\n      this.animate();\n\n      // Play\n      this.play();\n    },\n    initWorld() {\n      // To display anything with ThreeJS we need a scene, a camera and a renderer\n      const gameNode = document.getElementById(\"game\");\n      scene = new THREE.Scene();\n\n      // Ambient light\n      light = new THREE.AmbientLight(0x404040, 3.8); // soft white light\n      scene.add(light);\n\n      // Directional light\n      light = new THREE.DirectionalLight(0xc33e3e, 0.8);\n      light.position.set(0, 10, 6);\n      light.target.position.set(-1, -1, -1);\n      scene.add(light);\n      scene.add(light.target);\n\n      camera = new THREE.PerspectiveCamera(\n        75,\n        gameNode.clientWidth / gameNode.clientHeight,\n        0.1,\n        1000\n      );\n      renderer = new THREE.WebGLRenderer();\n      renderer.setSize(gameNode.clientWidth, gameNode.clientHeight);\n      document.getElementById(\"game\").appendChild(renderer.domElement);\n    },\n    createObject(index) {\n      const geometry = this.getRandomGeometry();\n\n      const color = this.getRandomColor();\n      const material = new THREE.MeshPhongMaterial({ color: color });\n\n      let obj = new THREE.Mesh(geometry, material);\n\n      const numObjects = this.rules[this.level].numObjects;\n\n      obj.position.y = index < numObjects / 2 ? 1.2 : -1.2;\n\n      let numObjsRow = Math.ceil(numObjects / 2);\n      let relObjIndex = index % numObjsRow;\n\n      if (obj.position.y < 0 && numObjsRow * 2 > numObjects)\n        numObjsRow = numObjsRow - 1;\n\n      if (numObjsRow % 2 == 1) {\n        let centerObj = Math.trunc(numObjsRow / 2);\n\n        if (relObjIndex == centerObj) {\n          // Pos 0,0\n          obj.position.x = 0;\n        } else if (relObjIndex < centerObj) {\n          // Left\n          obj.position.x = -2 * (centerObj - relObjIndex);\n        } else {\n          // Right\n          obj.position.x = 2 * (relObjIndex - centerObj);\n        }\n      } else {\n        if (relObjIndex < numObjsRow / 2) {\n          obj.position.x = -(1 + 2 * (numObjsRow / 2 - (relObjIndex + 1)));\n        } else {\n          obj.position.x =\n            1 + 2 * (numObjsRow / 2 - (numObjsRow - relObjIndex));\n        }\n      }\n\n      objects.push(obj);\n      scene.add(obj); // By default puts the cube at (0,0,0), the same coordinates where the camera is so we need to move the camera\n    },\n    animate() {\n      resquestAnimationId = requestAnimationFrame(this.animate);\n      this.animateObjects();\n      renderer.render(scene, camera);\n    },\n    animateObjects() {\n      for (let i = 0; i < objects.length; i++) {\n        if (animations.length < objects.length) {\n          animations.push(this.generateAnimation());\n        }\n        objects[i].rotation.x += animations[i].rotX;\n        objects[i].rotation.y += animations[i].rotY;\n        objects[i].rotation.z += animations[i].rotZ;\n      }\n    },\n    generateAnimation() {\n      switch (this.getRandom(0, 6)) {\n        case 0:\n          return {\n            rotX: this.getRandomNotTrunc(-0.05, 0.05),\n            rotY: 0,\n            rotZ: 0,\n          };\n        case 1:\n          return {\n            rotX: 0,\n            rotY: this.getRandomNotTrunc(-0.05, 0.05),\n            rotZ: 0,\n          };\n        case 2:\n          return {\n            rotX: 0,\n            rotY: 0,\n            rotZ: this.getRandomNotTrunc(-0.05, 0.05),\n          };\n        case 3:\n          return {\n            rotX: this.getRandomNotTrunc(-0.05, 0.05),\n            rotY: this.getRandomNotTrunc(-0.05, 0.05),\n            rotZ: 0,\n          };\n        case 4:\n          return {\n            rotX: this.getRandomNotTrunc(-0.05, 0.05),\n            rotY: 0,\n            rotZ: this.getRandomNotTrunc(-0.05, 0.05),\n          };\n        case 5:\n          return {\n            rotX: 0,\n            rotY: this.getRandomNotTrunc(-0.05, 0.05),\n            rotZ: this.getRandomNotTrunc(-0.05, 0.05),\n          };\n        default:\n          return {\n            rotX: this.getRandomNotTrunc(-0.05, 0.05),\n            rotY: this.getRandomNotTrunc(-0.05, 0.05),\n            rotZ: this.getRandomNotTrunc(-0.05, 0.05),\n          };\n      }\n    },\n    getRandom(min, max) {\n      return Math.trunc(Math.random() * (max - min) + min); // min included, max excluded\n    },\n    getRandomNotTrunc(min, max) {\n      let num = Math.random() * (max - min) + min; // min included, max excluded\n      if (num < 0.02 && num > -0.02) return this.getRandomNotTrunc(min, max);\n      else return num;\n    },\n    getRandomColor() {\n      while (true) {\n        const index = this.getRandom(0, COLORS.length);\n        if (!colorsIndexSelected.includes(index)) {\n          colorsIndexSelected.push(index);\n          return COLORS[index];\n        }\n      }\n    },\n    getRandomGeometry() {\n      const NUM_GEOMETRIES = 6;\n      let geo = this.getRandom(0, NUM_GEOMETRIES);\n\n      if (geometriesSelected.includes(geo))\n        geo = this.getRandom(0, NUM_GEOMETRIES);\n\n      let cont = 0;\n      while (geometriesSelected.includes(geo) && cont < NUM_GEOMETRIES) {\n        geo = this.getRandom(0, NUM_GEOMETRIES);\n        cont++;\n      }\n      geometriesSelected.push(geo);\n\n      switch (geo) {\n        case 0:\n          return new THREE.BoxGeometry();\n        case 1:\n          return new THREE.ConeGeometry();\n        case 2:\n          return new THREE.IcosahedronGeometry(0.8);\n        case 3:\n          return new THREE.OctahedronGeometry(0.8);\n        case 4:\n          return new THREE.TorusGeometry(0.5, 0.2);\n        case 5:\n          return new THREE.SphereGeometry(0.7);\n        default:\n          return new THREE.TorusKnotGeometry(0.3);\n      }\n    },\n    getCanvasRelativePosition(event) {\n      const canvas = renderer.domElement;\n      const rect = canvas.getBoundingClientRect();\n      return {\n        x: ((event.clientX - rect.left) * canvas.width) / rect.width,\n        y: ((event.clientY - rect.top) * canvas.height) / rect.height,\n      };\n    },\n    setPickPosition(event) {\n      const canvas = renderer.domElement;\n      const pos = this.getCanvasRelativePosition(event);\n\n      pickPosition.x = (pos.x / canvas.width) * 2 - 1;\n      pickPosition.y = (pos.y / canvas.height) * -2 + 1;\n\n      let delta = clock.getDelta();\n      pickHelper.pick(pickPosition, scene, camera, delta, this.userSequence);\n\n      for (let i = 0; i < this.userSequence.length; i++) {\n        if (this.userSequence[i] != this.sequence[i])\n          this.lose();\n        else if (i == this.sequence.length - 1)\n          this.win();\n      }\n\n    },\n    play() {\n      const newSeqItem = this.getRandom(0, this.rules[this.level].numObjects);\n      this.sequence.push(objects[newSeqItem]);\n      let lastColor = null;\n\n      // Time to start the visualization of the sequence\n      setTimeout(() => {\n        for (let i = 0; i < this.sequence.length; i++) {\n\n          if (i == 0) {\n            lastColor = this.sequence[i].material.emissive.getHex();\n            this.sequence[i].material.emissive.setHex(SHINE_COLOR);\n          }\n\n          setTimeout(() => {\n            this.sequence[i].material.emissive.setHex(lastColor);\n\n            setTimeout(() => {\n              if (i < this.sequence.length - 1) {\n                lastColor = this.sequence[i + 1].material.emissive.getHex();\n                this.sequence[i + 1].material.emissive.setHex(SHINE_COLOR);\n              }\n              else if (i == this.sequence.length - 1) {\n                const node = document.getElementById(\"countdown\");\n                node.style.visibility = \"visible\";\n                node.textContent = \"¡TE TOCA!\";\n\n                setTimeout(() => {\n                  node.style.visibility = \"hidden\";\n                }, 500);\n\n                // Dispatch event to start user turn\n                this.checkUserSequence();\n              }\n            }, 500);\n          }, (i * this.rules[this.level].timeObjectIlluminated + this.rules[this.level].timeObjectIlluminated) * 1000 - 500 );\n        \n        }\n      }, 1000)\n\n    },\n    checkUserSequence() {\n      // Change remaining time\n      remandingTimeIntervalId = setInterval( () => this.time--, 1000);\n\n      // If time it out lose the game\n      loseTimeoutId = setTimeout(() => {\n        clearInterval(remandingTimeIntervalId);\n        this.lose();\n      }, (this.sequence.length * this.rules[this.level].timeMultiplier) * 1000);\n\n      // Check the sequence\n      // Clicks\n      pickPosition = { x: -10000, y: -10000 };\n      pickHelper = new PickHelper();\n      window.addEventListener('click', this.setPickPosition);\n    },\n    reset() {\n      this.sequence = [];\n      this.userSequence = [];\n      this.sequenceSize = 0;\n      this.time = 0;\n      this.running = false;\n      objects = [];\n      animations = []; \n      colorsIndexSelected = [];\n      geometriesSelected = [];\n      scene = null;\n      camera = null; \n    },\n    resetThreeJS() {\n      cancelAnimationFrame(resquestAnimationId);\n      renderer = null; \n      light = null;\n      clock = null;\n      pickPosition = null;\n      pickHelper = null; \n    },\n    lose() {\n      window.removeEventListener('click', this.setPickPosition);\n      const loseRound = this.round - 1;\n      this.reset(); \n      this.resetThreeJS();\n      this.$emit('changeState', { \n                                  state: STATES.LOSE_STATE,\n                                  level: this.level, \n                                  sendPuntuation: true,  \n                                  round: loseRound,  \n                                  objects: [],\n                                  animations: [],\n                                  sequence: null,\n                                  scene: null,\n                                  camera: null,\n                                });\n    },\n    win() {\n      clearInterval(remandingTimeIntervalId);\n      clearTimeout(loseTimeoutId);\n      window.removeEventListener('click', this.setPickPosition);\n\n      this.resetThreeJS();\n      \n      this.$emit('changeState', { \n                                  state: STATES.WIN_STATE, \n                                  sendPuntuation: false,  \n                                  level: this.level, \n                                  round: this.round,  \n                                  objects: objects,\n                                  animations: animations,\n                                  sequence: this.sequence,\n                                  scene: scene,\n                                  camera: camera\n                                });\n    },\n    fillNotFirstRoundInfo() {\n      if (this.roundInfo != null && this.roundInfo.round != null) {\n        this.round = this.roundInfo.round;\n        objects = this.roundInfo.objects;\n        animations = this.roundInfo.animations;\n        this.sequence = this.roundInfo.sequence;\n        escene = this.roundInfo.escene;\n        camera = this.roundInfo.camera;\n      }\n      else {\n        this.reset();\n        this.resetThreeJS();\n      }\n    }\n  },\n};\n</script>\n\n<style scoped>\n.containerGame {\n  background-color: black;\n  height: 100%;\n  width: 100%;\n}\n\n.info {\n  width: 100%;\n  background: lightgrey;\n  color: black;\n}\n\n#game {\n  height: 100%;\n  background: black;\n}\n\n#countdown {\n  background-color: crimson;\n  height: 30px;\n  color: white;\n  text-align: center;\n  font-size: 20px;\n  z-index: -1;\n}\n\n</style>\n","body {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n\n    background-color: lightslategray;\n}\n\n#app {\n    display: flex;\n    justify-content: center;\n    width: 100%;\n}\n\n.containerGame[data-v-d7696a] {\n  background-color: black;\n  height: 100%;\n  width: 100%;\n}\n.info[data-v-d7696a] {\n  width: 100%;\n  background: lightgrey;\n  color: black;\n}\n#game[data-v-d7696a] {\n  height: 100%;\n  background: black;\n}\n#countdown[data-v-d7696a] {\n  background-color: crimson;\n  height: 30px;\n  color: white;\n  text-align: center;\n  font-size: 20px;\n  z-index: -1;\n}\n\n\n\n.cont {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  height: 200px;\n  padding: 40px 40px 40px 40px;\n  background: rgb(29, 45, 99);\n}\n.buttons {\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: space-around;\n}\n\n\n\n.container {\n  display: flex;\n  flex-direction: column;\n  color: #cfcfcf;\n}\np {\n  max-width: 50%;\n  text-align: center;\n}\n\n\n.container {\n  display: flex;\n  flex-direction: column;\n}\n\n\n.container {\n  display: flex;\n  flex-direction: column;\n}\n\n\n.container {\n  display: flex;\n  flex-direction: column;\n}\n\n\n.container {\n  display: flex;\n  flex-direction: column;\n}\n\n\n.container {\n  width: 80%;\n  height: 700px;\n  background-color: rgb(9, 24, 73);\n  overflow: hidden;\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n/*# sourceMappingURL=index.7d32048a.css.map */\n","<template>\n  <div class=\"cont\">\n    <n-form :label-width=\"80\">\n      <n-form-item label=\"Email\" path=\"user.email\">\n        <n-input v-model:value=\"user.email\" placeholder=\"Email\" />\n      </n-form-item>\n      <n-form-item label=\"Contraseña\" type=\"\" path=\"user.password\">\n        <n-input\n          v-model:value=\"user.password\"\n          type=\"password\"\n          placeholder=\"Contraseña\"\n        />\n      </n-form-item>\n      <n-form-item>\n        <div class=\"buttons\">\n          <n-button secondary type=\"success\" @click=\"signin\">Entrar</n-button>\n          <n-button type=\"primary\" @click=\"signup\">Registrarse</n-button>\n        </div>\n      </n-form-item>\n    </n-form>\n  </div>\n</template>\n\n<script>\nimport {\n  getAuth,\n  createUserWithEmailAndPassword,\n  signInWithEmailAndPassword,\n} from \"firebase/auth\";\nimport { NButton, NForm, NInput, NFormItem } from \"naive-ui\";\n\nexport default {\n  name: \"Login\",\n  components: {\n    NButton,\n    NInput,\n    NForm,\n    NFormItem,\n  },\n  data() {\n    return {\n      formValue: \"\",\n      user: {\n        email: \"\",\n        password: \"\",\n      },\n    };\n  },\n  methods: {\n    signup() {\n      const auth = getAuth();\n      createUserWithEmailAndPassword(auth, this.user.email, this.user.password)\n        .then((userCredential) => {\n          // Signed in\n          const user = userCredential.user;\n          this.$emit(\"logged\", user);\n        })\n        .catch((error) => {\n          window.alert(`Error ${error.code}: ${error.message}`);\n        });\n    },\n    signin() {\n      const auth = getAuth();\n      signInWithEmailAndPassword(auth, this.user.email, this.user.password)\n        .then((userCredential) => {\n          // Signed in\n          const user = userCredential.user;\n          this.$emit(\"logged\", user);\n        })\n        .catch((error) => {\n          window.alert(`Error ${error.code}: ${error.message}`);\n        });\n    },\n  },\n};\n</script>\n\n<style>\n.cont {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  height: 200px;\n  padding: 40px 40px 40px 40px;\n  background: rgb(29, 45, 99);\n}\n\n.buttons {\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: space-around;\n}\n\n</style>","<template>\n  <div class=\"container\">\n    <h2>Instrucciones</h2>\n    <p>En el juego Simón Dice, intenta memorizar la serie de objetos iluminados y reproducirla, en cada paso se agrega una nueva clave a la serie y el juego se vuelve más difícil. El juego termina cuando el jugador comete el primer error (cuando el jugador presiona el objeto iluminado incorrecto).\nEl propósito del juego es reproducir las series más largas de colores / sonidos generados aleatoriamente por el juego.\nPuedes cambiar el nivel de dificultad del juego</p><br>\n    <n-button type=\"primary\" @click=\"nextState\">Siguiente</n-button>\n  </div>\n</template>\n\n<script>\nimport { NButton } from \"naive-ui\";\nimport { STATES } from \"../../assets/variables\";\n\nexport default {\n  name: \"Instructions\",\n  components: {\n    NButton\n  },\n  data() {\n    return {};\n  },\n  methods: {\n    nextState() {\n      this.$emit('changeState', { state: STATES.CHOOSE_LEVEL_STATE });\n    }\n  }\n};\n</script>\n\n<style>\n.container {\n  display: flex;\n  flex-direction: column;\n  color: #cfcfcf;\n}\n\np {\n  max-width: 50%;\n  text-align: center;\n}\n</style>","<template>\n  <div class=\"container\">\n    <h2>¡Perdiste! :(</h2>\n    <n-button type=\"primary\" @click=\"nextState\">Volver al menú principal</n-button>\n  </div>\n</template>\n\n<script>\nimport { NButton } from \"naive-ui\";\nimport { STATES } from \"../../assets/variables\";\n\nexport default {\n  name: \"Lose\",\n  components: {\n    NButton,\n  },\n  data() {\n    return {};\n  },\n  methods: {\n    nextState() {\n      this.$emit(\"changeState\", { state: STATES.CHOOSE_LEVEL_STATE });\n    },\n  },\n};\n</script>\n\n<style>\n.container {\n  display: flex;\n  flex-direction: column;\n}\n</style>","<template>\n  <div class=\"container\">\n    <Login v-if=\"currentState === states.LOGIN_STATE\" v-on:logged=\"setLoggedUser\"></Login>\n\t\t<Instructions v-else-if=\"currentState === states.INSTRUCTION_STATE\" v-on:changeState=\"nextState\"></Instructions>\n\t\t<Level v-if=\"currentState === states.CHOOSE_LEVEL_STATE\" v-on:changeState=\"nextState\"></Level>\n\t\t<Game v-if=\"currentState === states.GAME_STATE\" v-on:changeState=\"nextState\" :level=level :roundInfo=roundInfo></Game>\n\t\t<Ranking v-if=\"currentState === states.RANKINGS_STATE\" v-on:changeState=\"nextState\"></Ranking>\n\t\t<Win v-if=\"currentState === states.WIN_STATE\" v-on:changeState=\"nextState\" :level=level :roundInfo=roundInfo></Win>\n\t\t<Lose v-if=\"currentState === states.LOSE_STATE\" v-on:changeState=\"nextState\"></Lose> \n  </div>\n</template>\n\n<script>\nimport Game from \"./components/Game.vue\";\nimport Login from \"./components/Login.vue\";\nimport Instructions from \"./components/Instructions.vue\";\nimport Level from \"./components/Level.vue\";\nimport Ranking from \"./components/Ranking.vue\";\nimport Win from \"./components/Win.vue\";\nimport Lose from \"./components/Lose.vue\";\n\nimport { STATES } from \"../assets/variables\";\nimport { postRanking, getRankings } from \"./firebase\";\n\nexport default {\n  name: \"App\",\n  components: {\n    Game,\n    Login,\n    Instructions,\n    Level,\n    Ranking,\n    Win,\n    Lose,\n  },\n  data() {\n    return {\n      name: \"Vue\",\n      loggedUser: false,\n      level: null,\n      user: {\n        email: \"\",\n        name: \"\",\n      },\n      roundInfo: {},\n      currentState: STATES.LOGIN_STATE,\n\t\t\tstates: STATES\n    };\n  },\n  methods: {\n    setLoggedUser(user) {\n      this.loggedUser = true;\n      this.user.email = user.email;\n      this.user.name = this.user.email.split(\"@\")[0];\n      this.nextState({ state: STATES.INSTRUCTION_STATE });\n    },\n    nextState(args) {\n      this.currentState = args.state;\n      this.roundInfo = {\n        level: args.level, \n        round: args.round,  \n        objects: args.objects,\n        animations: args.animations,\n        sequence: args.sequence,\n        renderer: args.renderer,\n        colorsIndexSelected: args.colorsIndexSelected,\n        geometriesSelected: args.geometriesSelected,\n        scene: args.scene,\n        camera: args.camera, \n        light: args.light,\n        clock: args.clock,\n      };\n\n      if (args.sendPuntuation != undefined && args.sendPuntuation == true) {\n        postRanking(this.user.name, this.roundInfo.round, this.roundInfo.level);\n      }\n\n      this.level = args.level;\n    },\n  },\n};\n</script>\n\n<style>\n.container {\n  width: 80%;\n  height: 700px;\n  background-color: rgb(9, 24, 73);\n  overflow: hidden;\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n</style>\n"],"names":[],"version":3,"file":"index.7d32048a.css.map"}